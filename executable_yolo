#!/usr/bin/env bash

# YOLO - AI CLI Tool Wrapper with Worktree Support
# Automatically adds bypass/danger flags to AI CLI tools and optionally
# creates isolated git worktrees for agent sessions.
#
# Part of the AI-Aligned toolchain:
# - ai-aligned-git: Git wrapper for safe AI commit practices
# - ai-aligned-gh: GitHub CLI wrapper for proper AI attribution
# - ai-aligned-yolo: AI CLI launcher with worktree isolation
#
# Copyright 2025 Lars Trieloff
# Licensed under the Apache License, Version 2.0

set -euo pipefail

VERSION="1.0.0"

# Color output helpers
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Enable colored output if stdout is a terminal
if [[ -t 1 ]]; then
    USE_COLOR=true
else
    USE_COLOR=false
fi

print_error() {
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${RED}yolo: $*${NC}" >&2
    else
        echo "yolo: $*" >&2
    fi
}

print_warning() {
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${YELLOW}yolo: $*${NC}" >&2
    else
        echo "yolo: $*" >&2
    fi
}

print_info() {
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${BLUE}$*${NC}" >&2
    else
        echo "$*" >&2
    fi
}

print_success() {
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${GREEN}$*${NC}" >&2
    else
        echo "$*" >&2
    fi
}

print_debug() {
    if [[ "${YOLO_DEBUG:-false}" == "true" ]]; then
        if [[ "$USE_COLOR" == "true" ]]; then
            echo -e "${BLUE}[DEBUG] $*${NC}" >&2
        else
            echo "[DEBUG] $*" >&2
        fi
    fi
}

# Show usage information
show_usage() {
    cat << EOF
YOLO - AI CLI Tool Wrapper with Worktree Support

Usage: yolo [OPTIONS] [command] [args...]

Options:
  -w, --worktree    Create a git worktree in .yolo/ before running command
  -c, --clean       Automatically clean up worktree after command completes
  -nc, --no-clean   Preserve worktree after command completes (no prompt)
  -n, --dry-run     Show what would be executed without running it
  -m, --mop         Clean up all YOLO worktrees, branches, and processes
  -h, --help        Show this help message
  -v, --version     Show version information

Supported Commands:
  codex             Adds --dangerously-bypass-approvals-and-sandbox
  claude            Adds --dangerously-skip-permissions
  copilot           Adds --allow-all-tools --allow-all-paths
  droid             No extra flags added (prompt allowed positionally)
  amp               Adds --dangerously-allow-all
  cursor-agent      Adds --force
  gemini            Uses --yolo; adds -i when prompt present
  opencode          No extra flags added
  <other>           Adds --yolo (generic fallback)

Multi-agent Mode:
  Provide a comma-separated list of agents as the command to launch them in parallel
  inside zellij (preferred) or tmux if installed. Each agent runs in its own
  git worktree and its own pane/window. Up to 9 agents are supported.

  Example:
    yolo codex,claude,gemini "build a devcontainer and run tests"

Full YOLO Mode:
  Run 'yolo' without a command to randomly select an installed coding agent.
  You only live yolo - let fate decide which AI assistant you get!

Examples:
  yolo                             # Full YOLO mode - random agent selection
  yolo -w                          # Full YOLO mode in a new worktree
  yolo claude                      # Run claude with --dangerously-skip-permissions
  yolo -w claude "fix the bug"     # Create worktree, then run claude (prompt for cleanup)
  yolo -w -c claude "experiment"   # Create worktree, auto-cleanup after
  yolo -w -nc claude "keep this"   # Create worktree, preserve it after
  yolo copilot chat                # Run copilot chat with safety flags disabled

Worktree Mode:
  When using -w/--worktree flag:
  - Creates .yolo/ directory in repository root
  - Creates branch: <command>-N (where N is the lowest available number)
  - Creates worktree: .yolo/<command>-N
  - Changes to worktree directory before running command

Cleanup Mode:
  When using -m/--mop flag:
  - Removes all .yolo/ worktrees
  - Deletes all associated branches
  - Kills any processes running in .yolo/ directories
  - Use this to clean up orphaned worktrees from interrupted sessions

Part of the AI-Aligned toolchain. See:
  https://github.com/trieloff/ai-aligned-git
  https://github.com/trieloff/ai-aligned-gh

EOF
}

show_version() {
    echo "yolo version $VERSION"
}

# Check if we're in a git repository
is_git_repo() {
    git rev-parse --git-dir >/dev/null 2>&1
}

# Get the repository root directory
get_repo_root() {
    git rev-parse --show-toplevel 2>/dev/null || echo "$PWD"
}

# Create a git worktree for the command
# Sets global variables: YOLO_BRANCH_NAME, YOLO_WORKTREE_PATH, YOLO_REPO_ROOT
create_worktree() {
    local command_name="$1"

    if ! is_git_repo; then
        print_error "not in a git repository, cannot create worktree"
        return 1
    fi

    YOLO_REPO_ROOT="$(get_repo_root)"

    local yolo_dir="$YOLO_REPO_ROOT/.yolo"
    if [[ ! -d "$yolo_dir" ]]; then
        mkdir -p "$yolo_dir"
        print_info "Created .yolo directory"
    fi

    # Find the lowest available number for this agent
    local agent_number=1
    while git rev-parse --verify "$command_name-$agent_number" >/dev/null 2>&1 || \
          [[ -d "$yolo_dir/$command_name-$agent_number" ]]; do
        ((agent_number++))
    done

    YOLO_BRANCH_NAME="$command_name-$agent_number"
    YOLO_WORKTREE_PATH="$yolo_dir/$command_name-$agent_number"

    print_info "Creating worktree at $YOLO_WORKTREE_PATH with branch $YOLO_BRANCH_NAME"

    # Create the worktree
    if ! git worktree add -b "$YOLO_BRANCH_NAME" "$YOLO_WORKTREE_PATH" 2>&1; then
        print_error "failed to create worktree"
        return 1
    fi

    print_success "Worktree created successfully"
    print_info "Switching to worktree..."

    # Change to the worktree directory
    cd "$YOLO_WORKTREE_PATH" || {
        print_error "failed to change to worktree directory"
        return 1
    }

    print_success "Now in: $YOLO_WORKTREE_PATH"
    return 0
}

# Get the appropriate flags for a command
get_command_flags() {
    local cmd="$1"

    # Check for environment-based flag override
    # e.g., YOLO_FLAGS_claude="--custom-flag"
    # Note: hyphens in command names are converted to underscores for env var
    local env_var_name="${cmd//-/_}"
    local env_var="YOLO_FLAGS_${env_var_name}"
    if [[ -n "${!env_var:-}" ]]; then
        echo "${!env_var}"
        return
    fi

    # Default flags based on command
    case "$cmd" in
        codex)
            echo "--dangerously-bypass-approvals-and-sandbox"
            ;;
        claude)
            echo "--dangerously-skip-permissions"
            ;;
        copilot)
            echo "--allow-all-tools --allow-all-paths"
            ;;
        droid)
            # droid does not support a yolo-style bypass flag; no extra flags
            echo ""
            ;;
        amp)
            echo "--dangerously-allow-all"
            ;;
        cursor-agent)
            echo "--force"
            ;;
        opencode)
            # opencode doesn't need extra flags
            echo ""
            ;;
        *)
            echo "--yolo"
            ;;
    esac
}

# Check if a command exists in PATH
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Get all installed supported coding agents
get_installed_agents() {
    local agents=()
    local supported_commands=("codex" "claude" "copilot" "droid" "amp" "cursor-agent" "opencode" "gemini")

    for cmd in "${supported_commands[@]}"; do
        if command_exists "$cmd"; then
            agents+=("$cmd")
        fi
    done

    printf "%s\n" "${agents[@]}"
}

# Compute a near-square grid for N panes (max 9)
compute_grid_for_n() {
    local n="$1"
    if (( n < 1 )); then n=1; fi
    if (( n > 9 )); then n=9; fi
    # Start with floor(sqrt(n)) rows and ceil(n/rows) cols
    local r c s
    s=$(awk -v n="$n" 'BEGIN{print int(sqrt(n))}')
    if [[ -z "$s" || "$s" == 0 ]]; then s=1; fi
    r=$s
    # ceiling division
    c=$(( (n + r - 1) / r ))
    # if still not enough (edge rounding), adjust
    while (( r * c < n )); do
        ((r++))
        c=$(( (n + r - 1) / r ))
    done
    echo "$r $c"
}

# Determine terminal size (rows cols)
detect_terminal_size() {
    local rows cols
    if rows_cols=$(stty size 2>/dev/null); then
        rows="${rows_cols%% *}"
        cols="${rows_cols##* }"
    else
        rows=$(tput lines 2>/dev/null || echo 24)
        cols=$(tput cols 2>/dev/null || echo 80)
    fi
    echo "$rows $cols"
}

# Detect if running inside Ghostty terminal
is_ghostty() {
    [[ "${TERM_PROGRAM:-}" == "ghostty" ]] || [[ -n "${GHOSTTY_BIN_DIR:-}" ]]
}

# Choose multiplexer: prefer Ghostty when inside it and AppleScript is available, then zellij, then tmux; empty if none
choose_multiplexer() {
    if is_ghostty && command_exists osascript; then
        echo ghostty
        return 0
    fi
    if command_exists zellij; then
        echo zellij
        return 0
    fi
    if command_exists tmux; then
        echo tmux
        return 0
    fi
    echo ""
}

# Escape an array of command+args into a safe single line for shells
join_escaped() {
    local out=""
    local i
    for i in "$@"; do
        # printf %q handles proper escaping for bash-compatible shells
        if [[ -z "$out" ]]; then
            out=$(printf %q "$i")
        else
            out+=" "
            out+=$(printf %q "$i")
        fi
    done
    echo "$out"
}

# Escape a string for safe inclusion in simple KDL string literals
kdl_escape() {
    local s="$1"
    s="${s//\\/\\\\}"
    s="${s//"\""/\\\"}"
    echo "$s"
}

# Convert backslash-escaped string to a typeable command
# Converts: say\ your\ name  →  "say your name" (adds quotes for multi-word args)
# Converts: \"quoted\"  →  "quoted"
convert_to_typeable() {
    local cmd="$1"
    local result=""
    local word=""

    # Parse word by word, tracking if we need quotes
    local i=0
    while [ $i -lt ${#cmd} ]; do
        local char="${cmd:$i:1}"
        local next_char="${cmd:$i+1:1}"

        if [[ "$char" == "\\" ]]; then
            case "$next_char" in
                " "|","|"("|")"|'"'|"'")
                    # Escaped character - this indicates the word needs quotes
                    word+="$next_char"
                    ((i+=2))
                    ;;
                *)
                    # Not an escape sequence we care about, keep the backslash
                    word+="$char"
                    ((i++))
                    ;;
            esac
        elif [[ "$char" =~ [[:space:]\;] ]]; then
            # Whitespace or semicolon ends current word
            if [[ -n "$word" ]]; then
                # If word contains spaces or commas, quote it
                if [[ "$word" =~ [[:space:],] ]]; then
                    result+="\"$word\""
                else
                    result+="$word"
                fi
                word=""
            fi
            result+="$char"
            ((i++))
        else
            word+="$char"
            ((i++))
        fi
    done

    # Handle last word
    if [[ -n "$word" ]]; then
        if [[ "$word" =~ [[:space:],] ]]; then
            result+="\"$word\""
        else
            result+="$word"
        fi
    fi

    echo "$result"
}

# Send command to current Ghostty split via AppleScript
# shellcheck disable=SC2027,SC1078,SC2154
send_ghostty_command() {
    local cmd="$1"
    print_debug "Sending command to split: $cmd"

    # Convert backslash-escaped format to typeable format
    local typeable_cmd
    typeable_cmd=$(convert_to_typeable "$cmd")
    print_debug "Converted to typeable: $typeable_cmd"

    # Escape for AppleScript: both backslashes and quotes need escaping
    # This ensures AppleScript can parse the string literal correctly
    # shellcheck disable=SC2027,SC1078,SC2154
    local escaped_cmd
    escaped_cmd="$typeable_cmd"
    escaped_cmd="${escaped_cmd//\\/\\\\}"    # Escape backslashes: \ -> \\
    escaped_cmd="${escaped_cmd//\"/\\\"}"    # Escape quotes: " -> \"

    # Type the command and press return
    print_debug "AppleScript escaped: $escaped_cmd"
    osascript -e "tell application \"System Events\" to tell process \"Ghostty\" to keystroke \"$escaped_cmd\"" 2>&1 | head -3
    local rc1=$?
    print_debug "keystroke exit code: $rc1"
    sleep 0.1
    osascript -e 'tell application "System Events" to tell process "Ghostty" to keystroke return' 2>&1 | head -3
    local rc2=$?
    print_debug "return key exit code: $rc2"
    return 0
}

# Test mode: create N empty Ghostty splits
test_ghostty_splits() {
    local n="$1"

    if (( n < 2 || n > 9 )); then
        print_error "split count must be between 2 and 9"
        return 1
    fi

    if ! is_ghostty; then
        print_error "not running in Ghostty terminal"
        return 1
    fi

    print_info "Creating $n empty Ghostty splits for testing..."

    # Create dummy commands (just echo with split number)
    local -a dummy_cmds=()
    local i
    for i in $(seq 1 "$n"); do
        dummy_cmds+=("echo Split $i")
    done

    # Call the ghostty split logic
    run_multi_agents_ghostty "${dummy_cmds[@]}"

    print_success "Created $n splits. Check the layout!"
    return 0
}

# Launch multiple agents in Ghostty splits with per-agent worktrees
run_multi_agents_ghostty() {
    print_debug "run_multi_agents_ghostty called with ${#@} arguments"
    local -a agent_cmds=("$@")
    local n=${#agent_cmds[@]}
    print_debug "Number of agent commands: $n"

    if (( n < 1 )); then
        print_error "no agent commands provided"
        return 1
    fi

    # Ghostty has a practical limit for splits
    if (( n > 9 )); then
        print_warning "more than 9 agents; limiting to 9 for Ghostty"
        n=9
    fi

    # Detect terminal orientation
    local rows cols
    read -r rows cols < <(detect_terminal_size)
    local is_landscape=false
    if (( cols >= rows )); then
        is_landscape=true
    fi

    print_info "Creating Ghostty splits for $n agents (terminal: ${cols}x${rows})"
    print_debug "Orientation: landscape=$is_landscape"

    local i=0

    # First agent in current split
    print_debug "Sending first command (agent $i)"
    send_ghostty_command "${agent_cmds[$i]}"
    ((i++))

    # Create splits based on agent count and terminal orientation
    if (( n == 2 )); then
        # 2 agents: split horizontally (landscape) or vertically (portrait)
        if [[ "$is_landscape" == "true" ]]; then
            # 1|2
            osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' >/dev/null 2>&1
        else
            # 1 over 2
            osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
        fi
        sleep 0.4
        send_ghostty_command "${agent_cmds[$i]}"

    elif (( n == 3 )); then
        print_debug "Creating 3-agent layout"
        if [[ "$is_landscape" == "true" ]]; then
            # Landscape: 1|2|3 (three columns)
            print_debug "Creating first split right"
            osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' 2>&1 | head -3
            local rc=$?
            print_debug "Split Right #1 exit code: $rc"
            sleep 0.4
            print_debug "Sending second command (agent $i)"
            send_ghostty_command "${agent_cmds[$((i++))]}"

            print_debug "Creating second split right"
            osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' 2>&1 | head -3
            rc=$?
            print_debug "Split Right #2 exit code: $rc"
            sleep 0.4
            print_debug "Sending third command (agent $i)"
            send_ghostty_command "${agent_cmds[$i]}"
        else
            # Portrait: 1 over 2 over 3 (three rows)
            osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
            sleep 0.4
            send_ghostty_command "${agent_cmds[$((i++))]}"

            osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
            sleep 0.4
            send_ghostty_command "${agent_cmds[$i]}"
        fi

    elif (( n == 4 )); then
        # 4 agents: always 2x2 grid
        # Create: 1|2 then go left and split both down to get grid
        osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' >/dev/null 2>&1
        sleep 0.4
        send_ghostty_command "${agent_cmds[$((i++))]}"

        # Go back left and split down
        osascript -e 'tell application "System Events" to tell process "Ghostty" to key code 123 using {command down, option down}' >/dev/null 2>&1
        sleep 0.2
        osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
        sleep 0.4
        send_ghostty_command "${agent_cmds[$((i++))]}"

        # Go back up and right, then split down
        osascript -e 'tell application "System Events" to tell process "Ghostty" to key code 126 using {command down, option down}' >/dev/null 2>&1
        sleep 0.2
        osascript -e 'tell application "System Events" to tell process "Ghostty" to key code 124 using {command down, option down}' >/dev/null 2>&1
        sleep 0.2
        osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
        sleep 0.4
        send_ghostty_command "${agent_cmds[$i]}"

    elif (( n >= 5 )); then
        # 5-9 agents: generalized grid layout
        if [[ "$is_landscape" == "true" ]]; then
            # Landscape: calculate optimal rows x cols
            local rows cols
            # Use compute_grid_for_n to get dimensions
            read -r rows cols < <(compute_grid_for_n "$n")

            print_debug "Creating ${rows}x${cols} grid for $n agents"

            # Create first row by splitting right (cols-1) times
            local splits_right=$((cols - 1))
            for ((j=0; j<splits_right; j++)); do
                osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' >/dev/null 2>&1
                sleep 0.4
                if (( i < n )); then
                    send_ghostty_command "${agent_cmds[$((i++))]}"
                fi
            done

            # Now create remaining rows by splitting down at each column position
            # We're currently at the rightmost column
            # For each column (right to left), split down (rows-1) times
            local remaining_rows=$((rows - 1))
            for ((col=0; col<cols; col++)); do
                # At this column, split down for each remaining row
                for ((row=0; row<remaining_rows; row++)); do
                    if (( i >= n )); then
                        break 2  # Exit both loops if we've placed all agents
                    fi

                    # Split down at current position
                    osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
                    sleep 0.4
                    send_ghostty_command "${agent_cmds[$((i++))]}"
                done

                # Move left to next column (except after the last column)
                if (( col < cols - 1 )); then
                    osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Select Split Left" of menu 1 of menu item "Select Split" of menu "Window" of menu bar 1' >/dev/null 2>&1
                    sleep 0.2
                fi
            done

        else
            # Portrait: calculate optimal cols x rows (swap dimensions)
            local rows cols
            read -r rows cols < <(compute_grid_for_n "$n")
            # Swap for portrait
            local tmp=$rows; rows=$cols; cols=$tmp

            print_debug "Creating ${rows}x${cols} grid for $n agents (portrait)"

            # Create first column by splitting down (rows-1) times
            local splits_down=$((rows - 1))
            for ((j=0; j<splits_down; j++)); do
                osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
                sleep 0.4
                if (( i < n )); then
                    send_ghostty_command "${agent_cmds[$((i++))]}"
                fi
            done

            # Now create remaining columns by splitting right at each row position
            # We're currently at the bottommost row
            # For each row (bottom to top), split right (cols-1) times
            local remaining_cols=$((cols - 1))
            for ((row=0; row<rows; row++)); do
                # At this row, split right for each remaining column
                for ((col=0; col<remaining_cols; col++)); do
                    if (( i >= n )); then
                        break 2
                    fi

                    # Split right at current position
                    osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' >/dev/null 2>&1
                    sleep 0.4
                    send_ghostty_command "${agent_cmds[$((i++))]}"
                done

                # Move up to next row (except after the last row)
                if (( row < rows - 1 )); then
                    osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Select Split Up" of menu 1 of menu item "Select Split" of menu "Window" of menu bar 1' >/dev/null 2>&1
                    sleep 0.2
                fi
            done
        fi
    fi

    # Equalize splits to make them all the same size
    print_debug "Equalizing splits"
    sleep 0.5
    osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Equalize Splits" of menu 1 of menu item "Resize Split" of menu "Window" of menu bar 1' 2>&1 | head -3
    local eq_rc=$?
    print_debug "Equalize splits exit code: $eq_rc"

    print_success "Created $n agent splits in Ghostty with commands launched"
    print_debug "run_multi_agents_ghostty returning 0"
    return 0
}

# Launch multiple agents in panes/tabs with per-agent worktrees
run_multi_agents() {
    local agent_csv="$1"; shift || true
    local dry_run_flag="$1"; shift || true
    local auto_clean="$1"; shift || true
    local -a common_args=("$@")

    # Split and sanitize agents list
    IFS=',' read -r -a agents <<< "$agent_csv"
    local clean_agents=()
    local a
    for a in "${agents[@]}"; do
        a="${a## }"; a="${a%% }" # trim simple spaces
        [[ -n "$a" ]] && clean_agents+=("$a")
    done

    if (( ${#clean_agents[@]} == 0 )); then
        print_error "no agents provided in list"
        return 1
    fi
    if (( ${#clean_agents[@]} > 9 )); then
        print_warning "more than 9 agents requested; only first 9 will be used"
        clean_agents=("${clean_agents[@]:0:9}")
    fi

    local mux
    mux="$(choose_multiplexer)"
    if [[ -z "$mux" ]]; then
        print_error "neither tmux nor zellij found in PATH"
        return 1
    fi

    # Prepare per-agent commands, flags and dedicated worktrees
    local start_pwd="$PWD"
    local -a agent_cmds=()
    local -a agent_paths=()
    local -a agent_branches=()

    local agent
    for agent in "${clean_agents[@]}"; do
        # Build command for agent; prefer keeping sessions interactive while ensuring prompt runs
        local flags; flags="$(get_command_flags "$agent")"
        local cmd_arr=()
        local shell_cmd=""

        case "$agent" in
            amp)
                # Amp: start interactive; if prompt provided, feed it via stdin pipe
                if (( ${#common_args[@]} )); then
                    local prompt_joined
                    prompt_joined=$(printf '%s ' "${common_args[@]}"); prompt_joined=${prompt_joined%% }
                    if [[ -n "$flags" ]]; then
                        shell_cmd="echo $(printf %q "$prompt_joined") | amp $flags"
                    else
                        shell_cmd="echo $(printf %q "$prompt_joined") | amp"
                    fi
                else
                    cmd_arr+=("$agent")
                    if [[ -n "$flags" ]]; then
                        # shellcheck disable=SC2206
                        local flag_array=($flags)
                        cmd_arr+=("${flag_array[@]}")
                    fi
                fi
                ;;
            copilot)
                # Copilot: If prompt provided, run one-shot then resume most recent session
                if (( ${#common_args[@]} )); then
                    local prompt_joined
                    prompt_joined=$(printf '%s ' "${common_args[@]}"); prompt_joined=${prompt_joined%% }
                    local flags_str=""
                    if [[ -n "$flags" ]]; then flags_str="$flags"; fi
                    shell_cmd="copilot $flags_str -p $(printf %q \"$prompt_joined\"); copilot $flags_str --continue"
                else
                    cmd_arr+=("$agent")
                    if [[ -n "$flags" ]]; then
                        # shellcheck disable=SC2206
                        local flag_array=($flags)
                        cmd_arr+=("${flag_array[@]}")
                    fi
                fi
                ;;
            opencode)
                # opencode: use --prompt to seed the TUI
                cmd_arr+=("$agent")
                if (( ${#common_args[@]} )); then
                    local prompt_joined
                    prompt_joined=$(printf '%s ' "${common_args[@]}"); prompt_joined=${prompt_joined%% }
                    cmd_arr+=("--prompt" "$prompt_joined")
                fi
                ;;
            gemini)
                # gemini: add -i when prompt present to remain interactive
                cmd_arr+=("$agent")
                if [[ -n "$flags" ]]; then
                    # shellcheck disable=SC2206
                    local flag_array=($flags)
                    cmd_arr+=("${flag_array[@]}")
                fi
                if (( ${#common_args[@]} )); then
                    local prompt_joined
                    prompt_joined=$(printf '%s ' "${common_args[@]}"); prompt_joined=${prompt_joined%% }
                    cmd_arr+=("-i" "$prompt_joined")
                fi
                ;;
            droid)
                # droid: allow inline prompt to seed session
                cmd_arr+=("$agent")
                if (( ${#common_args[@]} )); then
                    cmd_arr+=("${common_args[@]}")
                fi
                ;;
            *)
                # Default: flags + positional prompt if provided
                cmd_arr+=("$agent")
                if [[ -n "$flags" ]]; then
                    # shellcheck disable=SC2206
                    local flag_array=($flags)
                    cmd_arr+=("${flag_array[@]}")
                fi
                if (( ${#common_args[@]} )); then
                    cmd_arr+=("${common_args[@]}")
                fi
                ;;
        esac

        # Create dedicated worktree for each agent
        if ! create_worktree "$agent"; then
            return 1
        fi
        # create_worktree sets globals: YOLO_WORKTREE_PATH, YOLO_BRANCH_NAME, YOLO_REPO_ROOT
        agent_paths+=("$YOLO_WORKTREE_PATH")
        agent_branches+=("$YOLO_BRANCH_NAME")

        # If copilot, ensure the worktree directory is trusted via --add-dir
        if [[ "$agent" == "copilot" ]]; then
            local flags_str=""
            if [[ -n "$flags" ]]; then flags_str="$flags"; fi
            if (( ${#common_args[@]} )); then
                local prompt_joined
                prompt_joined=$(printf '%s ' "${common_args[@]}"); prompt_joined=${prompt_joined%% }
                shell_cmd="copilot $flags_str --add-dir $(printf %q \"$YOLO_WORKTREE_PATH\") -p $(printf %q \"$prompt_joined\"); copilot $flags_str --add-dir $(printf %q \"$YOLO_WORKTREE_PATH\") --continue"
            else
                # Start interactive with directory trusted
                # shellcheck disable=SC2206
                cmd_arr=("copilot" $flags_str --add-dir "$YOLO_WORKTREE_PATH")
            fi
        fi

        # Return to the original directory to continue creating more worktrees
        cd "$start_pwd"

        if [[ -n "$shell_cmd" ]]; then
            agent_cmds+=("$shell_cmd")
        else
            agent_cmds+=("$(join_escaped "${cmd_arr[@]}")")
        fi
    done

    local n; n=${#agent_cmds[@]}
    local rows cols
    read -r rows cols < <(detect_terminal_size)
    local grid_r grid_c
    read -r grid_r grid_c < <(compute_grid_for_n "$n")

    if [[ "$dry_run_flag" == "true" ]]; then
        print_info "Dry-run: would launch $n agents in $mux using a ${grid_r}x${grid_c} grid ($rows x $cols terminal)"
        local i
        for i in "${!agent_cmds[@]}"; do
            echo "- ${clean_agents[$i]} @ ${agent_paths[$i]}: ${agent_cmds[$i]}"
        done
        return 0
    fi

    if [[ "$mux" == ghostty ]]; then
        print_info "Using Ghostty native splits for $n agents"
        print_debug "Building wrapped commands for $n agents"

        # Get repo root for cleanup
        local repo_root
        repo_root="$(get_repo_root)"

        # Build shell wrapper commands with automatic cleanup
        local -a wrapped_cmds=()
        local i
        for i in "${!agent_cmds[@]}"; do
            local worktree_path="${agent_paths[$i]}"
            local branch_name="${agent_branches[$i]}"
            local is_first_split=$((i == 0))

            # Build cleanup script that runs after agent exits
            local cleanup_script
            cleanup_script="cd $(printf %q "$repo_root"); git worktree remove $(printf %q "$worktree_path") --force; git branch -D $(printf %q "$branch_name")"

            # Add exit command for non-first splits to close them after cleanup
            if [[ "$is_first_split" == "0" ]]; then
                cleanup_script="$cleanup_script; exit"
            fi

            # Create wrapped command: cd to worktree, run agent, then cleanup
            local wrapped
            wrapped="cd $(printf %q "$worktree_path"); ${agent_cmds[$i]}; $cleanup_script"

            print_debug "Wrapped command $i: $wrapped"
            wrapped_cmds+=("$wrapped")
        done

        # Call Ghostty-specific implementation
        print_debug "Calling run_multi_agents_ghostty with ${#wrapped_cmds[@]} commands"
        run_multi_agents_ghostty "${wrapped_cmds[@]}"
        local ghostty_rc=$?
        print_debug "run_multi_agents_ghostty returned: $ghostty_rc"

        # Inform user about automatic cleanup
        print_info "Agents running in worktrees (auto-cleanup enabled):"
        local j
        for j in "${!agent_branches[@]}"; do
            print_info "  ${clean_agents[$j]}: ${agent_paths[$j]} (branch: ${agent_branches[$j]})"
        done
        print_success "When you exit an agent, its worktree will be automatically cleaned up"

        print_debug "run_multi_agents returning 0 from ghostty block"
        return 0

    elif [[ "$mux" == tmux ]]; then
        local session
        session="yolo-$(date +%s)"
        # Start detached session sized to current terminal, first pane at first agent path
        tmux new-session -d -s "$session" -x "$cols" -y "$rows" -c "${agent_paths[0]}"
        # Send first agent command
        tmux send-keys -t "$session":0.0 "${agent_cmds[0]}" C-m

        local i
        for i in $(seq 1 $((n-1))); do
            tmux split-window -t "$session":0 -c "${agent_paths[$i]}"
            tmux send-keys -t "$session":0 "${agent_cmds[$i]}" C-m
        done
        tmux select-layout -t "$session":0 tiled

        # If a common prompt was provided, broadcast it across panes
        if (( ${#common_args[@]} )); then
            local prompt_joined
            prompt_joined=$(printf '%s ' "${common_args[@]}"); prompt_joined=${prompt_joined%% }
            tmux set-window-option -t "$session":0 synchronize-panes on
            tmux send-keys -t "$session":0 -l "$prompt_joined"
            tmux send-keys -t "$session":0 C-m
            tmux set-window-option -t "$session":0 synchronize-panes off
        fi

        print_success "Launching tmux session: $session with $n panes"
        tmux attach-session -t "$session"

    else
        # zellij preferred: generate a temporary layout with rows/cols based on terminal size
        local layout_file
        layout_file="$(mktemp -t yolo-layout-XXXXXX.kdl)"

        # Determine orientation and distribute panes row-wise
        local orient
        if (( cols >= rows )); then
            orient="landscape"
        else
            orient="portrait"
        fi

        local R C
        read -r R C < <(compute_grid_for_n "$n")
        if [[ "$orient" == "portrait" ]]; then
            # Prefer more rows in portrait
            local tmp=$R; R=$C; C=$tmp
        fi

        # Build row sizes
        local remaining=$n
        local -a row_sizes=()
        local r_i
        for r_i in $(seq 1 "$R"); do
            if (( remaining <= 0 )); then break; fi
            if (( remaining >= C )); then
                row_sizes+=("$C")
                remaining=$((remaining - C))
            else
                row_sizes+=("$remaining")
                remaining=0
            fi
        done

        # Write KDL layout: one tab with horizontal rows and vertical panes per row
        {
          echo "layout {"
          echo "  pane split_direction=\"horizontal\" {"
          local index=0
          local row_count=${#row_sizes[@]}
          for r_i in $(seq 0 $((row_count-1))); do
            local cols_in_row=${row_sizes[$r_i]}
            echo "    pane split_direction=\"vertical\" {"
            for _ in $(seq 1 "$cols_in_row"); do
              local cmd path
              cmd=$(kdl_escape "${agent_cmds[$index]}")
              path=$(kdl_escape "${agent_paths[$index]}")
              echo "      pane cwd=\"$path\" {"
              echo "        command \"bash\""
              echo "        args \"-lc\" \"$cmd\""
              echo "      }"
              index=$((index+1))
            done
            echo "    }"
          done
          echo "  }"
          echo "}"
        } > "$layout_file"

        # Start a new named session with the layout and attach to it
        local session
        session="yolo-$(date +%s)"
        zellij -s "$session" --new-session-with-layout "$layout_file"
        print_success "Launching zellij session: $session with $n panes"
        zellij attach "$session"

        # Clean temporary layout after exit
        rm -f "$layout_file"
    fi

    # After session exits, handle cleanup
    if [[ -n "$auto_clean" ]]; then
        local repo_root
        repo_root="$(get_repo_root)"
        if [[ "$auto_clean" == "yes" ]]; then
            local j
            for j in "${!agent_branches[@]}"; do
                cleanup_worktree "${agent_branches[$j]}" "${agent_paths[$j]}" "$repo_root"
            done
        elif [[ "$auto_clean" == "no" ]]; then
            local j
            for j in "${!agent_branches[@]}"; do
                print_info "Worktree preserved at: ${agent_paths[$j]} (branch ${agent_branches[$j]})"
            done
        else
            local j
            for j in "${!agent_branches[@]}"; do
                prompt_cleanup "${agent_branches[$j]}" "${agent_paths[$j]}" "$repo_root"
            done
        fi
    fi

    return 0
}

# Pick a random agent from installed agents
pick_random_agent() {
    local -a agents
    local agent
    while IFS= read -r agent; do
        agents+=("$agent")
    done < <(get_installed_agents)

    if [[ ${#agents[@]} -eq 0 ]]; then
        print_error "no supported coding agents found in PATH"
        print_info "Supported agents: codex, claude, copilot, droid, amp, cursor-agent, opencode, gemini"
        return 1
    fi

    # Use RANDOM to pick a random index
    local random_index=$((RANDOM % ${#agents[@]}))
    echo "${agents[$random_index]}"
}

# Clean up worktree and branch
# Mop up all YOLO worktrees, branches, and processes
mop_cleanup() {
    print_info "YOLO Mop: Cleaning up all worktrees, branches, and processes"

    local repo_root
    repo_root="$(get_repo_root)"
    if [[ -z "$repo_root" ]]; then
        print_error "Not in a git repository"
        return 1
    fi

    cd "$repo_root" || return 1

    local yolo_dir="$repo_root/.yolo"

    # Find all processes running in .yolo directories
    print_info "Checking for processes running in .yolo directories..."
    local pids=()
    if [[ -d "$yolo_dir" ]]; then
        while IFS= read -r pid; do
            if [[ -n "$pid" ]]; then
                pids+=("$pid")
            fi
        done < <(lsof +D "$yolo_dir" 2>/dev/null | tail -n +2 | awk '{print $2}' | sort -u)

        if (( ${#pids[@]} > 0 )); then
            print_warning "Found ${#pids[@]} process(es) running in .yolo directories"
            for pid in "${pids[@]}"; do
                local cmd
                cmd="$(ps -p "$pid" -o command= 2>/dev/null || echo "unknown")"
                print_info "  PID $pid: ${cmd:0:80}"
            done
            read -r -p "Kill these processes? (y/n): " response
            if [[ "$response" =~ ^[Yy]$ ]]; then
                for pid in "${pids[@]}"; do
                    if kill "$pid" 2>/dev/null; then
                        print_success "Killed process $pid"
                    else
                        print_warning "Failed to kill process $pid (may need sudo)"
                    fi
                done
                sleep 1
            fi
        else
            print_info "No processes found"
        fi
    fi

    # Remove all worktrees in .yolo/
    print_info "Removing all .yolo worktrees..."
    local removed_count=0
    while IFS= read -r worktree_path; do
        if [[ "$worktree_path" =~ \.yolo/ ]]; then
            if git worktree remove "$worktree_path" --force 2>/dev/null; then
                print_success "Removed: $worktree_path"
                ((removed_count++))
            else
                print_warning "Failed to remove: $worktree_path"
            fi
        fi
    done < <(git worktree list --porcelain | grep "^worktree " | cut -d' ' -f2)

    if (( removed_count == 0 )); then
        print_info "No worktrees found"
    fi

    # Delete all branches that were associated with worktrees
    print_info "Deleting associated branches..."
    local branch_count=0
    while IFS= read -r branch; do
        # Look for branches that match agent naming patterns or have .yolo in description
        if git branch -D "$branch" 2>/dev/null; then
            print_success "Deleted branch: $branch"
            ((branch_count++))
        fi
    done < <(git branch | sed 's/^[* ] //' | grep -E '^(claude|codex|copilot|amp|opencode|gemini|droid|cursor-agent)-[0-9]+$')

    if (( branch_count == 0 )); then
        print_info "No agent branches found"
    fi

    # Remove .yolo directory if empty
    if [[ -d "$yolo_dir" ]]; then
        if [[ -z "$(ls -A "$yolo_dir")" ]]; then
            rmdir "$yolo_dir"
            print_success "Removed empty .yolo directory"
        else
            print_warning ".yolo directory still contains files"
            ls -la "$yolo_dir"
        fi
    fi

    print_success "Mop complete!"
    return 0
}

cleanup_worktree() {
    local branch_name="$1"
    local worktree_path="$2"
    local repo_root="$3"

    print_info "Cleaning up worktree..."

    # Go back to repository root
    cd "$repo_root" || {
        print_error "failed to return to repository root"
        return 1
    }

    # Remove the worktree
    if git worktree remove "$worktree_path" 2>/dev/null; then
        print_success "Removed worktree: $worktree_path"
    else
        print_warning "Failed to remove worktree (may need manual cleanup)"
    fi

    # Delete the branch
    if git branch -D "$branch_name" >/dev/null 2>&1; then
        print_success "Deleted branch: $branch_name"
    else
        print_warning "Failed to delete branch (may need manual cleanup)"
    fi

    return 0
}

# Prompt user for cleanup
prompt_cleanup() {
    local branch_name="$1"
    local worktree_path="$2"
    local repo_root="$3"

    echo ""
    print_info "Worktree session completed."
    read -r -p "Clean up worktree and branch? (y/n): " response

    case "$response" in
        [yY]|[yY][eE][sS])
            cleanup_worktree "$branch_name" "$worktree_path" "$repo_root"
            ;;
        *)
            print_info "Worktree preserved at: $worktree_path"
            print_info "To clean up later, run:"
            echo "  git worktree remove $worktree_path"
            echo "  git branch -D $branch_name"
            ;;
    esac
}
# Main function
main() {
    local use_worktree=false
    local dry_run=false
    local auto_clean=""
    local command_name=""
    local command_args=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            -w|--worktree)
                use_worktree=true
                shift
                ;;
            -c|--clean)
                auto_clean="yes"
                shift
                ;;
            -nc|--no-clean)
                auto_clean="no"
                shift
                ;;
            -n|--dry-run)
                dry_run=true
                shift
                ;;
            -m|--mop)
                mop_cleanup
                exit 0
                ;;
            -s|--split-only)
                shift
                if [[ -z "$1" || ! "$1" =~ ^[0-9]+$ ]]; then
                    print_error "--split-only requires a number argument"
                    exit 1
                fi
                test_ghostty_splits "$1"
                exit $?
                ;;
            -*)
                print_error "unknown option: $1"
                echo ""
                show_usage
                exit 1
                ;;
            *)
                # First non-option argument is the command
                if [[ -z "$command_name" ]]; then
                    command_name="$1"
                    shift
                    # All remaining arguments are passed to the command
                    command_args=("$@")
                    break
                fi
                ;;
        esac
    done

    # If no command was provided, pick a random one (full yolo mode!)
    if [[ -z "$command_name" ]]; then
        print_info "Full YOLO mode activated! Picking a random coding agent..."
        command_name="$(pick_random_agent)" || exit 1
        print_success "Selected: $command_name"
        print_info ""
    fi

    # Multi-agent mode: if comma-separated list given, launch via tmux/zellij
    if [[ "$command_name" == *","* ]]; then
        # In multi-agent mode, we always create per-agent worktrees regardless of -w
        run_multi_agents "$command_name" "$dry_run" "$auto_clean" "${command_args[@]+"${command_args[@]}"}"
        exit $?
    fi

    # Check if command exists
    if ! command_exists "$command_name"; then
        print_warning "command '$command_name' not found in PATH"
        print_info "Will attempt to run it anyway..."
    fi

    # Create worktree if requested
    if [[ "$use_worktree" == "true" ]]; then
        if ! create_worktree "$command_name"; then
            exit 1
        fi
        # create_worktree sets YOLO_BRANCH_NAME, YOLO_WORKTREE_PATH, YOLO_REPO_ROOT
    fi

    # Build the final command (single-agent mode) with agent-specific argument semantics
    local flags; flags="$(get_command_flags "$command_name")"
    local full_command; full_command=("$command_name")

    case "$command_name" in
        amp)
            if (( ${#command_args[@]} )); then
                local prompt_joined
                prompt_joined=$(printf '%s ' "${command_args[@]}"); prompt_joined=${prompt_joined%% }
                if [[ -n "$flags" ]]; then
                    full_command=(bash -lc "echo $(printf %q "$prompt_joined") | amp $flags")
                else
                    full_command=(bash -lc "echo $(printf %q "$prompt_joined") | amp")
                fi
            else
                if [[ -n "$flags" ]]; then
                    # shellcheck disable=SC2206
                    local flag_array=($flags)
                    full_command+=("${flag_array[@]}")
                fi
            fi
            ;;
        copilot)
            if (( ${#command_args[@]} )); then
                local prompt_joined
                prompt_joined=$(printf '%s ' "${command_args[@]}"); prompt_joined=${prompt_joined%% }
                local flags_str=""
                if [[ -n "$flags" ]]; then flags_str="$flags"; fi
                # Trust the current directory explicitly
                local trust_dir
                trust_dir=$(pwd)
                full_command=(bash -lc "copilot $flags_str --add-dir $(printf %q \"$trust_dir\") -p $(printf %q \"$prompt_joined\"); copilot $flags_str --add-dir $(printf %q \"$trust_dir\") --continue")
            else
                if [[ -n "$flags" ]]; then
                    # shellcheck disable=SC2206
                    local flag_array=($flags)
                    full_command+=("${flag_array[@]}")
                fi
                # Trust current dir for interactive session
                local trust_dir
                trust_dir=$(pwd)
                full_command+=(--add-dir "$trust_dir")
            fi
            ;;
        opencode)
            if (( ${#command_args[@]} )); then
                local prompt_joined
                prompt_joined=$(printf '%s ' "${command_args[@]}"); prompt_joined=${prompt_joined%% }
                full_command=("$command_name" --prompt "$prompt_joined")
            fi
            ;;
        gemini)
            if [[ -n "$flags" ]]; then
                # shellcheck disable=SC2206
                local flag_array=($flags)
                full_command+=("${flag_array[@]}")
            fi
            if (( ${#command_args[@]} )); then
                local prompt_joined
                prompt_joined=$(printf '%s ' "${command_args[@]}"); prompt_joined=${prompt_joined%% }
                full_command+=("-i" "$prompt_joined")
            fi
            ;;
        droid)
            # droid: pass prompt positionally; no special flags
            if (( ${#command_args[@]} )); then
                full_command+=("${command_args[@]}")
            fi
            ;;
        *)
            if [[ -n "$flags" ]]; then
                # shellcheck disable=SC2206
                local flag_array=($flags)
                full_command+=("${flag_array[@]}")
            fi
            if (( ${#command_args[@]} )); then
                full_command+=("${command_args[@]}")
            fi
            ;;
    esac

    # Dry-run mode: show what would be executed without running
    if [[ "$dry_run" == "true" ]]; then
        print_info "Dry-run mode - would execute:"
        echo "${full_command[*]}"
        exit 0
    fi

    # Print what we're about to execute (for transparency)
    if [[ "${YOLO_DEBUG:-false}" == "true" ]]; then
        print_info "Executing: ${full_command[*]}"
    fi

    # Execute the command (not using exec so we can cleanup after)
    "${full_command[@]}"
    local exit_code=$?

    # Handle cleanup if worktree was created
    if [[ "$use_worktree" == "true" && -n "$YOLO_BRANCH_NAME" ]]; then
        if [[ "$auto_clean" == "yes" ]]; then
            # Automatic cleanup
            cleanup_worktree "$YOLO_BRANCH_NAME" "$YOLO_WORKTREE_PATH" "$YOLO_REPO_ROOT"
        elif [[ "$auto_clean" == "no" ]]; then
            # No cleanup, just inform
            print_info "Worktree preserved at: $YOLO_WORKTREE_PATH"
        else
            # Prompt user
            prompt_cleanup "$YOLO_BRANCH_NAME" "$YOLO_WORKTREE_PATH" "$YOLO_REPO_ROOT"
        fi
    fi

    exit $exit_code
}

# Run main function
main "$@"
