#!/usr/bin/env bash

# YOLO - AI CLI Tool Wrapper with Worktree Support
# Automatically adds bypass/danger flags to AI CLI tools and optionally
# creates isolated git worktrees for agent sessions.
#
# Part of the AI-Aligned toolchain:
# - ai-aligned-git: Git wrapper for safe AI commit practices
# - ai-aligned-gh: GitHub CLI wrapper for proper AI attribution
# - ai-aligned-yolo: AI CLI launcher with worktree isolation
#
# Copyright 2025 Lars Trieloff
# Licensed under the Apache License, Version 2.0

set -euo pipefail

VERSION="1.0.0"

# Color output helpers
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Enable colored output if stdout is a terminal
if [[ -t 1 ]]; then
    USE_COLOR=true
else
    USE_COLOR=false
fi

print_error() {
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${RED}yolo: $*${NC}" >&2
    else
        echo "yolo: $*" >&2
    fi
}

print_warning() {
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${YELLOW}yolo: $*${NC}" >&2
    else
        echo "yolo: $*" >&2
    fi
}

print_info() {
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${BLUE}$*${NC}" >&2
    else
        echo "$*" >&2
    fi
}

print_success() {
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${GREEN}$*${NC}" >&2
    else
        echo "$*" >&2
    fi
}

# Show usage information
show_usage() {
    cat << EOF
YOLO - AI CLI Tool Wrapper with Worktree Support

Usage: yolo [OPTIONS] <command> [args...]

Options:
  -w, --worktree    Create a git worktree in .conductor/ before running command
  -c, --clean       Automatically clean up worktree after command completes
  -nc, --no-clean   Preserve worktree after command completes (no prompt)
  -n, --dry-run     Show what would be executed without running it
  -h, --help        Show this help message
  -v, --version     Show version information

Supported Commands:
  codex             Adds --dangerously-bypass-approvals-and-sandbox
  claude            Adds --dangerously-skip-permissions
  copilot           Adds --allow-all-tools --allow-all-paths
  droid             Adds --skip-permissions-unsafe
  amp               Adds --dangerously-allow-all
  cursor-agent      Adds --force
  opencode          No extra flags added
  <other>           Adds --yolo (generic fallback)

Examples:
  yolo claude                      # Run claude with --dangerously-skip-permissions
  yolo -w claude "fix the bug"     # Create worktree, then run claude (prompt for cleanup)
  yolo -w -c claude "experiment"   # Create worktree, auto-cleanup after
  yolo -w -nc claude "keep this"   # Create worktree, preserve it after
  yolo copilot chat                # Run copilot chat with safety flags disabled

Worktree Mode:
  When using -w/--worktree flag:
  - Creates .conductor/ directory in repository root
  - Creates branch: <command>-N (where N is the lowest available number)
  - Creates worktree: .conductor/<command>-N
  - Changes to worktree directory before running command

Part of the AI-Aligned toolchain. See:
  https://github.com/trieloff/ai-aligned-git
  https://github.com/trieloff/ai-aligned-gh

EOF
}

show_version() {
    echo "yolo version $VERSION"
}

# Check if we're in a git repository
is_git_repo() {
    git rev-parse --git-dir >/dev/null 2>&1
}

# Get the repository root directory
get_repo_root() {
    git rev-parse --show-toplevel 2>/dev/null || echo "$PWD"
}

# Create a git worktree for the command
# Sets global variables: YOLO_BRANCH_NAME, YOLO_WORKTREE_PATH, YOLO_REPO_ROOT
create_worktree() {
    local command_name="$1"

    if ! is_git_repo; then
        print_error "not in a git repository, cannot create worktree"
        return 1
    fi

    YOLO_REPO_ROOT="$(get_repo_root)"

    local conductor_dir="$YOLO_REPO_ROOT/.conductor"
    if [[ ! -d "$conductor_dir" ]]; then
        mkdir -p "$conductor_dir"
        print_info "Created .conductor directory"
    fi

    # Find the lowest available number for this agent
    local agent_number=1
    while git rev-parse --verify "$command_name-$agent_number" >/dev/null 2>&1 || \
          [[ -d "$conductor_dir/$command_name-$agent_number" ]]; do
        ((agent_number++))
    done

    YOLO_BRANCH_NAME="$command_name-$agent_number"
    YOLO_WORKTREE_PATH="$conductor_dir/$command_name-$agent_number"

    print_info "Creating worktree at $YOLO_WORKTREE_PATH with branch $YOLO_BRANCH_NAME"

    # Create the worktree
    if ! git worktree add -b "$YOLO_BRANCH_NAME" "$YOLO_WORKTREE_PATH" 2>&1; then
        print_error "failed to create worktree"
        return 1
    fi

    print_success "Worktree created successfully"
    print_info "Switching to worktree..."

    # Change to the worktree directory
    cd "$YOLO_WORKTREE_PATH" || {
        print_error "failed to change to worktree directory"
        return 1
    }

    print_success "Now in: $YOLO_WORKTREE_PATH"
    return 0
}

# Get the appropriate flags for a command
get_command_flags() {
    local cmd="$1"

    # Check for environment-based flag override
    # e.g., YOLO_FLAGS_claude="--custom-flag"
    # Note: hyphens in command names are converted to underscores for env var
    local env_var_name="${cmd//-/_}"
    local env_var="YOLO_FLAGS_${env_var_name}"
    if [[ -n "${!env_var:-}" ]]; then
        echo "${!env_var}"
        return
    fi

    # Default flags based on command
    case "$cmd" in
        codex)
            echo "--dangerously-bypass-approvals-and-sandbox"
            ;;
        claude)
            echo "--dangerously-skip-permissions"
            ;;
        copilot)
            echo "--allow-all-tools --allow-all-paths"
            ;;
        droid)
            echo "--skip-permissions-unsafe"
            ;;
        amp)
            echo "--dangerously-allow-all"
            ;;
        cursor-agent)
            echo "--force"
            ;;
        opencode)
            # opencode doesn't need extra flags
            echo ""
            ;;
        *)
            echo "--yolo"
            ;;
    esac
}

# Check if a command exists in PATH
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Clean up worktree and branch
cleanup_worktree() {
    local branch_name="$1"
    local worktree_path="$2"
    local repo_root="$3"

    print_info "Cleaning up worktree..."

    # Go back to repository root
    cd "$repo_root" || {
        print_error "failed to return to repository root"
        return 1
    }

    # Remove the worktree
    if git worktree remove "$worktree_path" 2>/dev/null; then
        print_success "Removed worktree: $worktree_path"
    else
        print_warning "Failed to remove worktree (may need manual cleanup)"
    fi

    # Delete the branch
    if git branch -D "$branch_name" >/dev/null 2>&1; then
        print_success "Deleted branch: $branch_name"
    else
        print_warning "Failed to delete branch (may need manual cleanup)"
    fi

    return 0
}

# Prompt user for cleanup
prompt_cleanup() {
    local branch_name="$1"
    local worktree_path="$2"
    local repo_root="$3"

    echo ""
    print_info "Worktree session completed."
    read -r -p "Clean up worktree and branch? (y/n): " response

    case "$response" in
        [yY]|[yY][eE][sS])
            cleanup_worktree "$branch_name" "$worktree_path" "$repo_root"
            ;;
        *)
            print_info "Worktree preserved at: $worktree_path"
            print_info "To clean up later, run:"
            echo "  git worktree remove $worktree_path"
            echo "  git branch -D $branch_name"
            ;;
    esac
}

# Main function
main() {
    local use_worktree=false
    local dry_run=false
    local auto_clean=""
    local command_name=""
    local command_args=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            -w|--worktree)
                use_worktree=true
                shift
                ;;
            -c|--clean)
                auto_clean="yes"
                shift
                ;;
            -nc|--no-clean)
                auto_clean="no"
                shift
                ;;
            -n|--dry-run)
                dry_run=true
                shift
                ;;
            -*)
                print_error "unknown option: $1"
                echo ""
                show_usage
                exit 1
                ;;
            *)
                # First non-option argument is the command
                if [[ -z "$command_name" ]]; then
                    command_name="$1"
                    shift
                    # All remaining arguments are passed to the command
                    command_args=("$@")
                    break
                fi
                ;;
        esac
    done

    # Check if command was provided
    if [[ -z "$command_name" ]]; then
        print_error "missing command argument"
        echo ""
        show_usage
        exit 1
    fi

    # Check if command exists
    if ! command_exists "$command_name"; then
        print_warning "command '$command_name' not found in PATH"
        print_info "Will attempt to run it anyway..."
    fi

    # Create worktree if requested
    if [[ "$use_worktree" == "true" ]]; then
        if ! create_worktree "$command_name"; then
            exit 1
        fi
        # create_worktree sets YOLO_BRANCH_NAME, YOLO_WORKTREE_PATH, YOLO_REPO_ROOT
    fi

    # Get the appropriate flags for this command
    local flags
    flags="$(get_command_flags "$command_name")"

    # Build the final command by properly splitting flags into array
    local full_command
    full_command=("$command_name")

    # Add flags if any (intentionally unquoted to allow word splitting)
    if [[ -n "$flags" ]]; then
        # shellcheck disable=SC2206
        local flag_array=($flags)
        full_command+=("${flag_array[@]}")
    fi

    # Add remaining arguments
    full_command+=("${command_args[@]}")

    # Dry-run mode: show what would be executed without running
    if [[ "$dry_run" == "true" ]]; then
        print_info "Dry-run mode - would execute:"
        echo "${full_command[*]}"
        exit 0
    fi

    # Print what we're about to execute (for transparency)
    if [[ "${YOLO_DEBUG:-false}" == "true" ]]; then
        print_info "Executing: ${full_command[*]}"
    fi

    # Execute the command (not using exec so we can cleanup after)
    "${full_command[@]}"
    local exit_code=$?

    # Handle cleanup if worktree was created
    if [[ "$use_worktree" == "true" && -n "$YOLO_BRANCH_NAME" ]]; then
        if [[ "$auto_clean" == "yes" ]]; then
            # Automatic cleanup
            cleanup_worktree "$YOLO_BRANCH_NAME" "$YOLO_WORKTREE_PATH" "$YOLO_REPO_ROOT"
        elif [[ "$auto_clean" == "no" ]]; then
            # No cleanup, just inform
            print_info "Worktree preserved at: $YOLO_WORKTREE_PATH"
        else
            # Prompt user
            prompt_cleanup "$YOLO_BRANCH_NAME" "$YOLO_WORKTREE_PATH" "$YOLO_REPO_ROOT"
        fi
    fi

    exit $exit_code
}

# Run main function
main "$@"
