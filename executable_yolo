#!/usr/bin/env bash

# YOLO - AI CLI Tool Wrapper with Worktree Support
# Automatically adds bypass/danger flags to AI CLI tools and optionally
# creates isolated git worktrees for agent sessions.
#
# Part of the AI-Aligned toolchain:
# - ai-aligned-git: Git wrapper for safe AI commit practices
# - ai-aligned-gh: GitHub CLI wrapper for proper AI attribution
# - ai-aligned-yolo: AI CLI launcher with worktree isolation
#
# Copyright 2025 Lars Trieloff
# Licensed under the Apache License, Version 2.0

set -euo pipefail

VERSION="1.1.0"

# Color output helpers
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Enable colored output if stdout is a terminal
if [[ -t 1 ]]; then
    USE_COLOR=true
else
    USE_COLOR=false
fi

print_error() {
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${RED}yolo: $*${NC}" >&2
    else
        echo "yolo: $*" >&2
    fi
}

print_warning() {
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${YELLOW}yolo: $*${NC}" >&2
    else
        echo "yolo: $*" >&2
    fi
}

print_info() {
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${BLUE}$*${NC}" >&2
    else
        echo "$*" >&2
    fi
}

print_success() {
    if [[ "$USE_COLOR" == "true" ]]; then
        echo -e "${GREEN}$*${NC}" >&2
    else
        echo "$*" >&2
    fi
}

print_debug() {
    if [[ "${YOLO_DEBUG:-false}" == "true" ]]; then
        if [[ "$USE_COLOR" == "true" ]]; then
            echo -e "${BLUE}[DEBUG] $*${NC}" >&2
        else
            echo "[DEBUG] $*" >&2
        fi
    fi
}

# Show usage information
show_usage() {
    cat << EOF
YOLO - AI CLI Tool Wrapper with Worktree Support

Usage: yolo [OPTIONS] [command] [args...]

Options:
  -w, --worktree    Create a git worktree in .yolo/ before running command
  -c, --clean       Automatically clean up worktree after command completes
  -nc, --no-clean   Preserve worktree after command completes (no prompt)
  -e, --editor      Launch \$EDITOR to compose prompt (works in all modes)
  -a, --all-agents, --waddan
                    Launch multi-agent mode with all supported agents found on system
  -n, --dry-run     Show what would be executed without running it
  -m, --mop         Clean up all YOLO worktrees, branches, and processes
  -h, --help        Show this help message
  -v, --version     Show version information

Supported Commands:
  codex             Adds --dangerously-bypass-approvals-and-sandbox
  claude            Adds --dangerously-skip-permissions
  copilot           Adds --allow-all-tools --allow-all-paths
  droid             No extra flags added (prompt allowed positionally)
  amp               Adds --dangerously-allow-all
  cursor-agent      Adds --force
  gemini            Uses --yolo; adds -i when prompt present
  qwen              Uses --yolo; adds -i when prompt present
  kimi              Uses --yolo (requires Ghostty for interactive prompts)
  opencode          No extra flags added
  crush             Uses --yolo (requires Ghostty for interactive prompts)
  aider             Uses --yes-always (requires Ghostty for interactive prompts)
  <other>           Adds --yolo (generic fallback)

Multi-agent Mode:
  Provide a comma-separated list of agents as the command to launch them in parallel
  inside Ghostty terminal. Each agent runs in its own git worktree and its own pane.
  Up to 12 agents are supported. Requires Ghostty terminal with AppleScript support.

  Example:
    yolo codex,claude,gemini "build a devcontainer and run tests"

Full YOLO Mode:
  Run 'yolo' without a command to randomly select an installed coding agent.
  You only live yolo - let fate decide which AI assistant you get!

Kimi CLI Detection:
  YOLO automatically detects when running inside Kimi CLI and provides enhanced
  integration. Look for the "Detected Kimi CLI environment!" message.

Examples:
  yolo                             # Full YOLO mode - random agent selection
  yolo -w                          # Full YOLO mode in a new worktree
  yolo -a "implement feature X"    # Launch all available agents in parallel
  yolo --waddan "build tests"      # Same as -a (alternative name)
  yolo -e -a                       # Compose prompt in editor, run all agents
  yolo -e claude                   # Compose prompt in editor, run claude
  yolo claude                      # Run claude with --dangerously-skip-permissions
  yolo -w claude "fix the bug"     # Create worktree, then run claude (prompt for cleanup)
  yolo -w -c claude "experiment"   # Create worktree, auto-cleanup after
  yolo -w -nc claude "keep this"   # Create worktree, preserve it after
  yolo -e codex,claude,gemini      # Compose prompt in editor, run 3 agents in parallel
  yolo copilot chat                # Run copilot chat with safety flags disabled
  yolo aider                       # Run aider with --yes-always
  yolo -w aider "implement feature" # Create worktree, run aider with prompt
  yolo aider "add authentication middleware" # Run aider with auto-approval
  yolo -e aider # Compose complex prompt in editor for aider

Worktree Mode:
  When using -w/--worktree flag:
  - Creates .yolo/ directory in repository root
  - Creates branch: <command>-N (where N is the lowest available number)
  - Creates worktree: .yolo/<command>-N
  - Changes to worktree directory before running command

Cleanup Mode:
  When using -m/--mop flag:
  - Removes all .yolo/ worktrees
  - Deletes all associated branches
  - Kills any processes running in .yolo/ directories
  - Use this to clean up orphaned worktrees from interrupted sessions

Part of the AI-Aligned toolchain. See:
  https://github.com/trieloff/ai-aligned-git
  https://github.com/trieloff/ai-aligned-gh

EOF
}

show_version() {
    echo "yolo version $VERSION"
}

# Check if we're in a git repository
is_git_repo() {
    git rev-parse --git-dir >/dev/null 2>&1
}

# Get the repository root directory
get_repo_root() {
    git rev-parse --show-toplevel 2>/dev/null || echo "$PWD"
}

# Sanitize a name to be valid for git branch names
# Removes/replaces invalid characters according to git-check-ref-format
sanitize_branch_name() {
    local name="$1"
    # Replace spaces and special chars with hyphens
    name="${name//[^a-zA-Z0-9._-]/-}"
    # Remove consecutive hyphens
    name="${name//-+/-}"
    # Remove leading/trailing hyphens and dots
    name="${name##[-.]}"
    name="${name%%[-.]}"
    # Ensure it's not empty
    if [[ -z "$name" ]]; then
        name="yolo-session"
    fi
    echo "$name"
}

# Create a git worktree for the command
# Sets global variables: YOLO_BRANCH_NAME, YOLO_WORKTREE_PATH, YOLO_REPO_ROOT
create_worktree() {
    local command_name="$1"

    if ! is_git_repo; then
        print_error "not in a git repository, cannot create worktree"
        return 1
    fi

    YOLO_REPO_ROOT="$(get_repo_root)"

    local yolo_dir="$YOLO_REPO_ROOT/.yolo"
    if [[ ! -d "$yolo_dir" ]]; then
        mkdir -p "$yolo_dir"
        print_info "Created .yolo directory"
    fi

    # Sanitize the command name for use in branch names
    local sanitized_name
    sanitized_name="$(sanitize_branch_name "$command_name")"
    
    # Find the lowest available number for this agent
    local agent_number=1
    while git rev-parse --verify "$sanitized_name-$agent_number" >/dev/null 2>&1 || \
          [[ -d "$yolo_dir/$sanitized_name-$agent_number" ]]; do
        ((agent_number++))
    done

    YOLO_BRANCH_NAME="$sanitized_name-$agent_number"
    YOLO_WORKTREE_PATH="$yolo_dir/$sanitized_name-$agent_number"

    print_info "Creating worktree at $YOLO_WORKTREE_PATH with branch $YOLO_BRANCH_NAME"

    # Create the worktree
    if ! git worktree add -b "$YOLO_BRANCH_NAME" "$YOLO_WORKTREE_PATH" 2>&1; then
        print_error "failed to create worktree"
        return 1
    fi

    print_success "Worktree created successfully"
    print_info "Switching to worktree..."

    # Change to the worktree directory
    cd "$YOLO_WORKTREE_PATH" || {
        print_error "failed to change to worktree directory"
        return 1
    }

    print_success "Now in: $YOLO_WORKTREE_PATH"
    return 0
}

# Get the appropriate flags for a command
get_command_flags() {
    local cmd="$1"

    # Check for environment-based flag override
    # e.g., YOLO_FLAGS_claude="--custom-flag"
    # Note: hyphens in command names are converted to underscores for env var
    # Sanitize command name for use as environment variable
    local env_var_name="${cmd//[^a-zA-Z0-9_]/_}"
    local env_var="YOLO_FLAGS_${env_var_name}"
    if [[ -n "${!env_var:-}" ]]; then
        echo "${!env_var}"
        return
    fi

    # Default flags based on command
    case "$cmd" in
        codex)
            echo "--dangerously-bypass-approvals-and-sandbox --search"
            ;;
        claude)
            echo "--dangerously-skip-permissions"
            ;;
        copilot)
            echo "--allow-all-tools --allow-all-paths"
            ;;
        droid)
            # droid does not support a yolo-style bypass flag; no extra flags
            echo ""
            ;;
        amp)
            echo "--dangerously-allow-all"
            ;;
        cursor-agent)
            echo "--force"
            ;;
        opencode)
            # opencode doesn't need extra flags
            echo ""
            ;;
        qwen)
            # qwen-specific bypass flag
            echo "--yolo"
            ;;
        kimi)
            # kimi uses --yolo for auto-approval
            echo "--yolo"
            ;;
        crush)
            # crush uses --yolo for auto-approval
            echo "--yolo"
            ;;
        aider)
            # aider uses --yes-always for auto-approval
            echo "--yes-always"
            ;;
        *)
            echo "--yolo"
            ;;
    esac
}

# Check if a command exists in PATH
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Get all installed supported coding agents
get_installed_agents() {
    local agents=()
    local supported_commands=("codex" "claude" "copilot" "droid" "amp" "cursor-agent" "opencode" "qwen" "gemini" "kimi" "crush" "aider")

    for cmd in "${supported_commands[@]}"; do
        if command_exists "$cmd"; then
            agents+=("$cmd")
        fi
    done

    printf "%s\n" "${agents[@]}"
}

# Compute a near-square grid for N panes (max 12)
compute_grid_for_n() {
    local n="$1"
    if (( n < 1 )); then n=1; fi
    if (( n > 12 )); then n=12; fi
    # Start with floor(sqrt(n)) rows and ceil(n/rows) cols
    local r c s
    s=$(awk -v n="$n" 'BEGIN{print int(sqrt(n))}')
    if [[ -z "$s" || "$s" == 0 ]]; then s=1; fi
    r=$s
    # ceiling division
    c=$(( (n + r - 1) / r ))
    # if still not enough (edge rounding), adjust
    while (( r * c < n )); do
        ((r++))
        c=$(( (n + r - 1) / r ))
    done
    echo "$r $c"
}

# Determine terminal size (rows cols)
detect_terminal_size() {
    local rows cols
    if rows_cols=$(stty size 2>/dev/null); then
        rows="${rows_cols%% *}"
        cols="${rows_cols##* }"
    else
        rows=$(tput lines 2>/dev/null || echo 24)
        cols=$(tput cols 2>/dev/null || echo 80)
    fi
    echo "$rows $cols"
}

# Detect if running inside Ghostty terminal
is_ghostty() {
    [[ "${TERM_PROGRAM:-}" == "ghostty" ]] || [[ -n "${GHOSTTY_BIN_DIR:-}" ]]
}

# Detect if running inside Kimi CLI by checking process tree
is_kimi_cli() {
    local pid=$$
    local max_depth=10
    local depth=0

    # Walk up the process tree to check if we're running under kimi
    while [[ $pid -ne 0 && $depth -lt $max_depth ]]; do
        local cmd
        if cmd=$(ps -p "$pid" -o command= 2>/dev/null); then
            # Extract the command name from the full command line
            local cmd_name="${cmd%% *}"  # Get first word (the executable)
            local base_name="${cmd_name##*/}"  # Get basename without path

            # Check if the executable is exactly "kimi"
            if [[ "$base_name" == "kimi" ]]; then
                return 0
            fi
        fi

        # Get parent process ID
        local ppid
        if ppid=$(ps -p "$pid" -o ppid= 2>/dev/null); then
            pid=$(echo "$ppid" | tr -d ' ')
        else
            break
        fi

        depth=$((depth + 1))
    done

    return 1
}

# Choose multiplexer: prefer Ghostty when inside it and AppleScript is available; empty if none
choose_multiplexer() {
    if is_ghostty && command_exists osascript; then
        echo ghostty
        return 0
    fi
    echo ""
}

# Escape an array of command+args into a safe single line for shells
join_escaped() {
    local out=""
    local i
    for i in "$@"; do
        # printf %q handles proper escaping for bash-compatible shells
        if [[ -z "$out" ]]; then
            out=$(printf %q "$i")
        else
            out+=" "
            out+=$(printf %q "$i")
        fi
    done
    echo "$out"
}

# Join command array for typing into a shell (not executing via shell)
# Arguments containing spaces/special chars are wrapped in quotes
# This is for Ghostty where commands are typed, not executed
join_for_typing() {
    local out=""
    local i
    for i in "$@"; do
        local escaped="$i"
        # If arg contains spaces, quotes, backticks, or special chars, wrap in quotes
        if [[ "$i" =~ [[:space:]\'\"\`\$\(\)] ]]; then
            # Escape internal quotes and backslashes for shell
            escaped="${i//\\/\\\\}"        # \ -> \\
            escaped="${escaped//\"/\\\"}"  # " -> \"
            escaped="\"$escaped\""         # wrap in quotes
        fi

        if [[ -z "$out" ]]; then
            out="$escaped"
        else
            out+=" $escaped"
        fi
    done
    echo "$out"
}

# Escape a string for safe inclusion in simple KDL string literals
kdl_escape() {
    local s="$1"
    s="${s//\\/\\\\}"
    s="${s//"\""/\\\"}"
    echo "$s"
}

# Send command to current Ghostty split via AppleScript
# Input: command string (may contain shell escaping)
# shellcheck disable=SC2027,SC1078,SC2154
send_ghostty_command() {
    local cmd="$1"
    print_debug "Sending command to split: $cmd"

    # Escape for AppleScript: backslashes and quotes need escaping
    # AppleScript string literals use backslash as escape character
    local escaped_cmd="$cmd"
    escaped_cmd="${escaped_cmd//\\/\\\\}"    # Escape backslashes first: \ → \\
    escaped_cmd="${escaped_cmd//\"/\\\"}"    # Then escape quotes: " → \"

    # Type the command and press return
    print_debug "AppleScript escaped: $escaped_cmd"
    osascript -e "tell application \"System Events\" to tell process \"Ghostty\" to keystroke \"$escaped_cmd\"" 2>&1 | head -3
    local rc1=$?
    print_debug "keystroke exit code: $rc1"
    sleep 0.5  # Increased delay for agents to process input
    osascript -e 'tell application "System Events" to tell process "Ghostty" to keystroke return' 2>&1 | head -3
    local rc2=$?
    print_debug "return key exit code: $rc2"
    return 0
}

# Test mode: create N empty Ghostty splits
test_ghostty_splits() {
    local n="$1"

    if (( n < 2 || n > 12 )); then
        print_error "split count must be between 2 and 12"
        return 1
    fi

    if ! is_ghostty; then
        print_error "not running in Ghostty terminal"
        return 1
    fi

    print_info "Creating $n empty Ghostty splits for testing..."

    # Create dummy commands (just echo with split number)
    local -a dummy_cmds=()
    local i
    for i in $(seq 1 "$n"); do
        dummy_cmds+=("echo Split $i")
    done

    # Call the ghostty split logic
    run_multi_agents_ghostty "${dummy_cmds[@]}"

    print_success "Created $n splits. Check the layout!"
    return 0
}

# Launch multiple agents in Ghostty splits with per-agent worktrees
run_multi_agents_ghostty() {
    print_debug "run_multi_agents_ghostty called with ${#@} arguments"
    local -a agent_cmds=("$@")
    local n=${#agent_cmds[@]}
    print_debug "Number of agent commands: $n"

    if (( n < 1 )); then
        print_error "no agent commands provided"
        return 1
    fi

    # Ghostty has a practical limit for splits
    if (( n > 12 )); then
        print_warning "more than 12 agents; limiting to 12 for Ghostty"
        n=12
    fi

    # Detect terminal orientation
    local rows cols
    read -r rows cols < <(detect_terminal_size)
    local is_landscape=false
    if (( cols >= rows )); then
        is_landscape=true
    fi

    print_info "Creating Ghostty splits for $n agents (terminal: ${cols}x${rows})"
    print_debug "Orientation: landscape=$is_landscape"

    local i=0

    # First agent in current split
    print_debug "Sending first command (agent $i)"
    send_ghostty_command "${agent_cmds[$i]}"
    ((i++))

    # Create splits based on agent count and terminal orientation
    if (( n == 2 )); then
        # 2 agents: split horizontally (landscape) or vertically (portrait)
        if [[ "$is_landscape" == "true" ]]; then
            # 1|2
            osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' >/dev/null 2>&1
        else
            # 1 over 2
            osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
        fi
        sleep 0.4
        send_ghostty_command "${agent_cmds[$i]}"

    elif (( n == 3 )); then
        print_debug "Creating 3-agent layout"
        if [[ "$is_landscape" == "true" ]]; then
            # Landscape: 1|2|3 (three columns)
            print_debug "Creating first split right"
            osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' 2>&1 | head -3
            local rc=$?
            print_debug "Split Right #1 exit code: $rc"
            sleep 0.4
            print_debug "Sending second command (agent $i)"
            send_ghostty_command "${agent_cmds[$((i++))]}"

            print_debug "Creating second split right"
            osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' 2>&1 | head -3
            rc=$?
            print_debug "Split Right #2 exit code: $rc"
            sleep 0.4
            print_debug "Sending third command (agent $i)"
            send_ghostty_command "${agent_cmds[$i]}"
        else
            # Portrait: 1 over 2 over 3 (three rows)
            osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
            sleep 0.4
            send_ghostty_command "${agent_cmds[$((i++))]}"

            osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
            sleep 0.4
            send_ghostty_command "${agent_cmds[$i]}"
        fi

    elif (( n == 4 )); then
        # 4 agents: always 2x2 grid
        # Create: 1|2 then go left and split both down to get grid
        osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' >/dev/null 2>&1
        sleep 0.4
        send_ghostty_command "${agent_cmds[$((i++))]}"

        # Go back left and split down
        osascript -e 'tell application "System Events" to tell process "Ghostty" to key code 123 using {command down, option down}' >/dev/null 2>&1
        sleep 0.2
        osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
        sleep 0.4
        send_ghostty_command "${agent_cmds[$((i++))]}"

        # Go back up and right, then split down
        osascript -e 'tell application "System Events" to tell process "Ghostty" to key code 126 using {command down, option down}' >/dev/null 2>&1
        sleep 0.2
        osascript -e 'tell application "System Events" to tell process "Ghostty" to key code 124 using {command down, option down}' >/dev/null 2>&1
        sleep 0.2
        osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
        sleep 0.4
        send_ghostty_command "${agent_cmds[$i]}"

    elif (( n >= 5 )); then
        # 5-12 agents: generalized grid layout
        if [[ "$is_landscape" == "true" ]]; then
            # Landscape: calculate optimal rows x cols
            local rows cols
            # Use compute_grid_for_n to get dimensions
            read -r rows cols < <(compute_grid_for_n "$n")

            print_debug "Creating ${rows}x${cols} grid for $n agents"

            # Create first row by splitting right (cols-1) times
            local splits_right=$((cols - 1))
            for ((j=0; j<splits_right; j++)); do
                osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' >/dev/null 2>&1
                sleep 0.4
                if (( i < n )); then
                    send_ghostty_command "${agent_cmds[$((i++))]}"
                fi
            done

            # Now create remaining rows by splitting down at each column position
            # We're currently at the rightmost column
            # For each column (right to left), split down (rows-1) times
            local remaining_rows=$((rows - 1))
            for ((col=0; col<cols; col++)); do
                # At this column, split down for each remaining row
                for ((row=0; row<remaining_rows; row++)); do
                    if (( i >= n )); then
                        break 2  # Exit both loops if we've placed all agents
                    fi

                    # Split down at current position
                    osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
                    sleep 0.4
                    send_ghostty_command "${agent_cmds[$((i++))]}"
                done

                # Move left to next column (except after the last column)
                if (( col < cols - 1 )); then
                    osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Select Split Left" of menu 1 of menu item "Select Split" of menu "Window" of menu bar 1' >/dev/null 2>&1
                    sleep 0.2
                fi
            done

        else
            # Portrait: calculate optimal cols x rows (swap dimensions)
            local rows cols
            read -r rows cols < <(compute_grid_for_n "$n")
            # Swap for portrait
            local tmp=$rows; rows=$cols; cols=$tmp

            print_debug "Creating ${rows}x${cols} grid for $n agents (portrait)"

            # Create first column by splitting down (rows-1) times
            local splits_down=$((rows - 1))
            for ((j=0; j<splits_down; j++)); do
                osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Down" of menu "File" of menu bar 1' >/dev/null 2>&1
                sleep 0.4
                if (( i < n )); then
                    send_ghostty_command "${agent_cmds[$((i++))]}"
                fi
            done

            # Now create remaining columns by splitting right at each row position
            # We're currently at the bottommost row
            # For each row (bottom to top), split right (cols-1) times
            local remaining_cols=$((cols - 1))
            for ((row=0; row<rows; row++)); do
                # At this row, split right for each remaining column
                for ((col=0; col<remaining_cols; col++)); do
                    if (( i >= n )); then
                        break 2
                    fi

                    # Split right at current position
                    osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' >/dev/null 2>&1
                    sleep 0.4
                    send_ghostty_command "${agent_cmds[$((i++))]}"
                done

                # Move up to next row (except after the last row)
                if (( row < rows - 1 )); then
                    osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Select Split Up" of menu 1 of menu item "Select Split" of menu "Window" of menu bar 1' >/dev/null 2>&1
                    sleep 0.2
                fi
            done
        fi
    fi

    # Equalize splits to make them all the same size
    print_debug "Equalizing splits"
    sleep 0.5
    osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Equalize Splits" of menu 1 of menu item "Resize Split" of menu "Window" of menu bar 1' 2>&1 | head -3
    local eq_rc=$?
    print_debug "Equalize splits exit code: $eq_rc"

    # Send delayed prompts to agents that need them (copilot, kimi)
    # Run in background so agents can start first, avoiding input buffering
    if [[ -n "${YOLO_AGENT_PROMPTS:-}" ]] && (( ${#YOLO_AGENT_PROMPTS[@]} > 0 )); then
        print_debug "Checking for delayed prompts to send..."
        local has_prompts=false
        local idx
        for idx in "${!YOLO_AGENT_PROMPTS[@]}"; do
            if [[ -n "${YOLO_AGENT_PROMPTS[$idx]}" ]]; then
                has_prompts=true
                break
            fi
        done

        if [[ "$has_prompts" == "true" ]]; then
            print_info "Prompts will be sent in background after agents start..."

            # Spawn background job to send prompts after delay
            (
                sleep 4  # Wait for agents to fully start and display banners

                # Navigate back to first split (go left/up multiple times to ensure we're at split 0)
                for ((nav=0; nav<n; nav++)); do
                    osascript -e 'tell application "System Events" to tell process "Ghostty" to key code 123 using {command down, option down}' >/dev/null 2>&1
                    sleep 0.1
                    osascript -e 'tell application "System Events" to tell process "Ghostty" to key code 126 using {command down, option down}' >/dev/null 2>&1
                    sleep 0.1
                done

                # Send prompts to each split in order
                for idx in "${!YOLO_AGENT_PROMPTS[@]}"; do
                    local prompt_text="${YOLO_AGENT_PROMPTS[$idx]}"
                    local agent_name="${YOLO_AGENT_NAMES[$idx]:-}"

                    if [[ -n "$prompt_text" ]]; then
                        # Ensure split is focused before sending
                        sleep 0.3

                        # copilot shows a dialog that needs to be dismissed first
                        if [[ "$agent_name" == "copilot" ]]; then
                            osascript -e 'tell application "System Events" to tell process "Ghostty" to keystroke return' >/dev/null 2>&1
                            sleep 1
                        fi

                        send_ghostty_command "$prompt_text"

                        # Wait for command to be processed before navigating away
                        sleep 1
                    fi

                    # Navigate to next split (right if landscape, down if portrait)
                    if (( idx < n - 1 )); then
                        if [[ "$is_landscape" == "true" ]]; then
                            osascript -e 'tell application "System Events" to tell process "Ghostty" to key code 124 using {command down, option down}' >/dev/null 2>&1
                        else
                            osascript -e 'tell application "System Events" to tell process "Ghostty" to key code 125 using {command down, option down}' >/dev/null 2>&1
                        fi
                        sleep 0.5
                    fi
                done
            ) &  # Run in background
        fi
    fi

    print_success "Created $n agent splits in Ghostty with commands launched"
    print_debug "run_multi_agents_ghostty returning 0"
    return 0
}

# Launch a single agent in a Ghostty split with prompt sent via AppleScript
# This is used for agents like copilot and kimi that don't support interactive launching with a prompt
# (Their prompt flags cause immediate exit after execution)
# Args: agent_cmd (launch command without prompt), prompt_text, is_copilot (optional, "true" if copilot)
run_single_agent_ghostty_with_prompt() {
    local agent_cmd="$1"
    local prompt_text="$2"
    local is_copilot="${3:-false}"
    local is_aider=false
    [[ "$agent_cmd" == *"aider"* ]] && is_aider=true

    if ! is_ghostty; then
        print_error "not running in Ghostty terminal"
        return 1
    fi

    print_info "Launching agent in new Ghostty split with prompt..."

    # Create a split (split right)
    print_debug "Creating split..."
    osascript -e 'tell application "System Events" to tell process "Ghostty" to click menu item "Split Right" of menu "File" of menu bar 1' >/dev/null 2>&1
    sleep 0.5

    # Launch the agent in the new split
    print_debug "Launching agent: $agent_cmd"
    send_ghostty_command "$agent_cmd"

    # Wait for agent to start and be ready for input
    # Different agents may have different startup times (kimi needs ~4s for welcome banner)
    print_debug "Waiting for agent to start..."
    sleep 4

    # Handle agents that need initial dialog dismissal
    if [[ "$is_copilot" == "true" || "$is_aider" == "true" ]]; then
        print_debug "Dismissing copilot/aider dialog..."
        # Send two returns to get past initial prompts
        osascript -e 'tell application "System Events" to tell process "Ghostty" to keystroke return' >/dev/null 2>&1
        sleep 0.5
        osascript -e 'tell application "System Events" to tell process "Ghostty" to keystroke return' >/dev/null 2>&1 
        sleep 1
        # For aider, send another return to get past the initial prompt
        if [[ "$agent_name" == "aider" ]]; then
            osascript -e 'tell application "System Events" to tell process "Ghostty" to keystroke return' >/dev/null 2>&1
            sleep 1
        fi
    fi

    # Send the prompt
    print_debug "Sending prompt via AppleScript: $prompt_text"
    send_ghostty_command "$prompt_text"

    print_success "Agent launched with prompt in split"
    return 0
}

# Launch multiple agents in panes/tabs with per-agent worktrees
run_multi_agents() {
    local agent_csv="$1"; shift || true
    local dry_run_flag="$1"; shift || true
    local auto_clean="$1"; shift || true
    local -a common_args=("$@")

    # Split and sanitize agents list
    IFS=',' read -r -a agents <<< "$agent_csv"
    local clean_agents=()
    local a
    for a in "${agents[@]}"; do
        a="${a## }"; a="${a%% }" # trim simple spaces
        [[ -n "$a" ]] && clean_agents+=("$a")
    done

    if (( ${#clean_agents[@]} == 0 )); then
        print_error "no agents provided in list"
        return 1
    fi
    if (( ${#clean_agents[@]} > 12 )); then
        print_warning "more than 12 agents requested; only first 12 will be used"
        clean_agents=("${clean_agents[@]:0:12}")
    fi

    local mux
    mux="$(choose_multiplexer)"
    if [[ -z "$mux" ]]; then
        print_error "Ghostty terminal with AppleScript support not available"
        print_info "Multi-agent mode requires Ghostty terminal"
        return 1
    fi

    # Prepare per-agent commands, flags and dedicated worktrees
    local start_pwd="$PWD"
    local -a agent_cmds=()
    local -a agent_paths=()
    local -a agent_branches=()
    local -a agent_prompts=()  # For agents that need delayed prompt sending

    local agent
    for agent in "${clean_agents[@]}"; do
        # Build command for agent; prefer keeping sessions interactive while ensuring prompt runs
        local flags; flags="$(get_command_flags "$agent")"
        local cmd_arr=()
        local shell_cmd=""

        case "$agent" in
            amp)
                # Amp: start interactive; if prompt provided, feed it via stdin pipe
                if (( ${#common_args[@]} )); then
                    local prompt_joined
                    prompt_joined=$(printf '%s ' "${common_args[@]}"); prompt_joined=${prompt_joined%% }
                    if [[ -n "$flags" ]]; then
                        shell_cmd="echo $(printf %q "$prompt_joined") | amp $flags"
                    else
                        shell_cmd="echo $(printf %q "$prompt_joined") | amp"
                    fi
                else
                    cmd_arr+=("$agent")
                    if [[ -n "$flags" ]]; then
                        # shellcheck disable=SC2206
                        local flag_array=($flags
